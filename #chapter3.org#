第3章 ブロック

* ブロックの基本

** yieldキーワードを使ってコールバック
def sample(a,b)
  a+yield(a,b)
end
sample(1,2){|x,y| (x + y)} #=> 4

** Kernel#block_givenで確認できる

* スコープの概要

** スコープと束縛

スコープを変えると、束縛は新しい束縛と交換される。
特に、ローカル変数はスコープごとに毎回変わる。

** スコープゲート

スコープが切り替わる場所(スコープゲート)は3つ。
^クラス定義 class
^モジュール定義 module
^メソッド呼び出し def

スコープゲートを飛び越えたければ、スコープゲートをメソッド呼び出しにする。

**  スコープのフラット化
スコープゲートをつくらないことで、スコープを変更させない。
2つのスコープを一緒の場所に押込むことで、変数を共有する。
これをフラットスコープと呼ぶ。

class宣言の変わりに、Class.new()。
module宣言の代わりに、Module.new()。
ブロックを渡せば、クラスにインスタンスメソッドが定義できる。
defの代わりに、Module#define_method()

var = "Scope gate"

MyClass = Class.new do
  puts "#{var} in class"

  define_method :my_method do
    puts "#{var} in method"
  end
end

MyClass.new.my_method #=> Scope gate in class, Scope gate in method

* ブロックをクロージャとして使う

** ブロック単体では実行できない
どんなコードも、変数やselfといった環境(束縛)が必要。
ブロックは、コードと束縛の集まりで構成される


** クロージャ
ブロックは、メソッドにある変数でなく、ブロックが定義されたときの変数を見る。

* instance_eval()でスコープを操作

** instance_eval()の概要
instance_eval()は、オブジェクトをブロックで評価できる。
instance_eval()でselfに変更を加えると、束縛が変更できる。

obj = String.new
v = 2
obj.instance_eval { @v = v } #=> 2
obj.instance_eval { @v } #=> 2

instance_evalに渡したブロックをコンテキスト探査機と呼ぶ。

** クリーンルーム
ブロックを評価するためだけにオブジェクトを生成することがある。
このオブジェクトをクリーンルームと呼ぶ。

* 呼び出し可能オブジェクトのチェックリスト

#ブロック
定義されたスコープで評価
#Proc
Procクラスのオブジェクト。定義されたスコープで評価
#lambda
Procクラスのオブジェクト。Procとは、引数やreturnの挙動などの違いがある。
定義されたスコープで評価
#メソッド
Methodクラスのオブジェクト。オブジェクトにひもづけられ、オブジェクトのスコープで評価。

* Proc/lambda でブロックを呼び出し可能オブジェクトに

** 呼び出し可能オブジェクト
「コードを保管して、あとで呼び出す」オブジェクトのこと。
Rubyには、おおまかに4つ。
^ブロック
^Proc (ブロックがオブジェクトになったもの)
^lambda (Procの変形)
^メソッド

** Procオブジェクト
ブロックはオブジェクトではない。
ブロックをオブジェクト化したものが、Proc。

Proc.new()にブロックを渡し、
Proc.call()で、ブロックを呼び出し評価する。

inc = Proc.new {|x| x + 1}
inc.call(2) #=> 3

ブロックをProcに変換するためのカーネルメソッドが、
lambda()
proc()

** &修飾
特定のブロックを使いたい場合、yieldでは役不足になる。
このとき、引数列の最後に、&の印のついた引数を置くことで解決できる。

^他のメソッドにブロックを渡したい
def math(a,b)
  yield(a,b)
end

def teach_math(a,b, &operate)
  puts math(a,b, &operate)
end

teach_math(2,3) { |x,y| x + y } #=> 5

^ブロックをProcに変換したい
def create_proc(&the_proc)
  the_proc
end
p = create_proc{ |name| "Hello, #{name}." }
puts p.class
puts p.call("Bill")


** lambdaの記法
Proc.new(と同じように書ける。
p = lambda {|x| x + 1 }

また1.9からは、矢印で書くこともできるようになった。
p = ->(x){x + 1}

** Proc と lambda の違い
ほとんどのrubyerは、lambdaを第一選択にする。

違い1 returnの意味

    def double(callable)
      callable.call * 2
    end

    # lambda
    l = lambda { return 10}
    puts double l #=> 20

    # Proc.new
    p1 = Proc.new { 10 }
    puts double p1 #=> 20

    p2 = Proc.new { return 10 }
    puts double p2 #=> unexpected return (LocalJumpError)

lambdaは、lambdaから戻る
Procは、Procが定義されたスコープから戻る。
たとえば、以下の例。
    def cant_double
      p = Proc.new {return 10}
      result = p.call
      return result * 2 # ここまで来ない
    end

    cant_double #=> 10

** 引数(arity)
lambdaは引数の数に厳格。(メソッドに近い)
Proc.new()は、寛容。
    l_arity = lambda { |a,b| [a,b] }
    p_arity = Proc.new { |a,b| [a,b]}


    p p_arity.call(1)     #=> ArgumentError
    p l_arity.call(1)     #=> [1,nil]
    p p_arity.call(1,2)   #=> [1,2]
    p l_arity.call(1,2)   #=> [1,2]
    p p_arity.call(1,2,3) #=> [1,2]
    p l_arity.call(1,2,3) #=> ArgumentError

** メソッドを呼び出し可能オブジェクトに Object#method()
以下のようにすると、メソッドをMethodオブジェクトとして取得できる。
Method#call()で実行。
ただし、Methodオブジェクトはlambdaと違い、属するオブジェクトのスコープで評価される。

    class CallMethod
      def initialize(value)
        @x = value
      end

      def my_method;puts @x;end
    end
    obj = CallMethod.new(1)
    m = obj.method :my_method
    m.call #=> 1
    obj.instance_eval { @x = 2 }
    m.call #=> 2

MethodオブジェクトはMethod#to_proc()でProcオブジェクトに変換できる。

